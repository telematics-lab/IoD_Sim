From 93313c29c015ea477fee8971e46d123261bcc730 Mon Sep 17 00:00:00 2001
From: Giovanni Grieco <giovanni@grieco.dev>
Date: Thu, 30 May 2024 12:22:02 +0200
Subject: [PATCH] mobility: Introduce GeocentricMobiltyModel API

---
 src/mobility/CMakeLists.txt                   |   2 +
 ...entric-constant-position-mobility-model.cc | 230 ++++--------------
 ...centric-constant-position-mobility-model.h | 103 +-------
 .../model/geocentric-mobility-model.cc        | 177 ++++++++++++++
 .../model/geocentric-mobility-model.h         | 153 ++++++++++++
 src/mobility/model/geographic-positions.h     |   7 +
 .../model/channel-condition-model.cc          |   8 +-
 .../model/three-gpp-propagation-loss-model.cc |  73 ++++--
 .../examples/three-gpp-ntn-channel-example.cc |   9 +-
 src/spectrum/model/three-gpp-channel-model.cc |  27 +-
 10 files changed, 475 insertions(+), 314 deletions(-)
 create mode 100644 src/mobility/model/geocentric-mobility-model.cc
 create mode 100644 src/mobility/model/geocentric-mobility-model.h

diff --git a/src/mobility/CMakeLists.txt b/src/mobility/CMakeLists.txt
index 50f67040b..3e4d8cf07 100644
--- a/src/mobility/CMakeLists.txt
+++ b/src/mobility/CMakeLists.txt
@@ -11,6 +11,7 @@ build_lib(
     model/constant-velocity-mobility-model.cc
     model/gauss-markov-mobility-model.cc
     model/geocentric-constant-position-mobility-model.cc
+    model/geocentric-mobility-model.cc
     model/geographic-positions.cc
     model/hierarchical-mobility-model.cc
     model/mobility-model.cc
@@ -33,6 +34,7 @@ build_lib(
     model/constant-velocity-mobility-model.h
     model/gauss-markov-mobility-model.h
     model/geocentric-constant-position-mobility-model.h
+    model/geocentric-mobility-model.h
     model/geographic-positions.h
     model/hierarchical-mobility-model.h
     model/mobility-model.h
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.cc b/src/mobility/model/geocentric-constant-position-mobility-model.cc
index 282feeeda..ecc0da563 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.cc
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.cc
@@ -4,9 +4,12 @@
  * SPDX-License-Identifier: GPL-2.0-only
  *
  * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #include "geocentric-constant-position-mobility-model.h"
 
+#include "geographic-positions.h"
+
 #include "ns3/angles.h"
 
 #include <math.h>
@@ -27,7 +30,7 @@ GeocentricConstantPositionMobilityModel::GetTypeId()
 {
     static TypeId tid =
         TypeId("ns3::GeocentricConstantPositionMobilityModel")
-            .SetParent<MobilityModel>()
+            .SetParent<GeocentricMobilityModel>()
             .SetGroupName("Mobility")
             .AddConstructor<GeocentricConstantPositionMobilityModel>()
             .AddAttribute(
@@ -37,194 +40,57 @@ GeocentricConstantPositionMobilityModel::GetTypeId()
                 "altitude",
                 Vector3DValue({0, 0, 0}),
                 MakeVector3DAccessor(&GeocentricConstantPositionMobilityModel::m_position),
-                MakeVector3DChecker())
-            .AddAttribute("GeographicReferencePoint",
-                          "The point, in meters, taken as reference when converting from "
-                          "geographic to topographic.",
-                          Vector3DValue({0, 0, 0}),
-                          MakeVector3DAccessor(
-                              &GeocentricConstantPositionMobilityModel::m_geographicReferencePoint),
-                          MakeVector3DChecker());
+                MakeVector3DChecker());
     return tid;
 }
 
 Vector
-GeocentricConstantPositionMobilityModel::GetGeographicPosition() const
-{
-    return DoGetGeographicPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetGeographicPosition(const Vector& latLonAlt)
-{
-    DoSetGeographicPosition(latLonAlt);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetGeocentricPosition() const
-{
-    return DoGetGeocentricPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetGeocentricPosition(const Vector& position)
-{
-    DoSetGeocentricPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    return DoGetElevationAngle(other);
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetCoordinateTranslationReferencePoint(
-    const Vector& position)
-{
-    DoSetCoordinateTranslationReferencePoint(position);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetCoordinateTranslationReferencePoint() const
-{
-    return DoGetCoordinateTranslationReferencePoint();
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::GetPosition() const
-{
-    return DoGetPosition();
-}
-
-void
-GeocentricConstantPositionMobilityModel::SetPosition(const Vector& position)
-{
-    return DoSetPosition(position);
-}
-
-double
-GeocentricConstantPositionMobilityModel::GetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    return DoGetDistanceFrom(other);
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetPosition() const
-{
-    Vector topographicCoordinates =
-        GeographicPositions::GeographicToTopocentricCoordinates(m_position,
-                                                                m_geographicReferencePoint,
-                                                                GeographicPositions::SPHERE);
-    return topographicCoordinates;
+GeocentricConstantPositionMobilityModel::DoGetPosition(PositionType type) const
+{
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        return GeographicPositions::GeographicToTopocentricCoordinates(
+            m_position,
+            GetGeographicReferencePoint(),
+            GetEarthSpheroidType());
+    case PositionType::GEOCENTRIC:
+        return GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
+                                                                     m_position.y,
+                                                                     m_position.z,
+                                                                     GetEarthSpheroidType());
+    case PositionType::GEOGRAPHIC:
+        return m_position;
+    default:
+        NS_ABORT_MSG("Unknown PositionType requested");
+    }
 }
 
 void
-GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position)
-{
-    Vector geographicCoordinates =
-        GeographicPositions::TopocentricToGeographicCoordinates(position,
-                                                                m_geographicReferencePoint,
-                                                                GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetDistanceFrom(
-    Ptr<const GeocentricConstantPositionMobilityModel> other) const
-{
-    Vector cartesianCoordA =
-        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
-                                                              m_position.y,
-                                                              m_position.z,
-                                                              GeographicPositions::SPHERE);
-    Vector cartesianCoordB = other->DoGetGeocentricPosition();
-
-    double distance = (cartesianCoordA - cartesianCoordB).GetLength();
-
-    return distance;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeographicPosition() const
-{
-    return m_position;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeographicPosition(const Vector& latLonAlt)
-{
-    NS_ASSERT_MSG((latLonAlt.x >= -90) && (latLonAlt.x <= 90),
-                  "Latitude must be between -90 deg and +90 deg");
-    NS_ASSERT_MSG(latLonAlt.z >= 0, "Altitude must be higher or equal than 0 meters");
-
-    m_position = latLonAlt;
-    // Normalize longitude to [-180, 180]
-    m_position.y = WrapTo180(m_position.y);
-    NotifyCourseChange();
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetGeocentricPosition() const
-{
-    Vector geocentricCoordinates =
-        GeographicPositions::GeographicToCartesianCoordinates(m_position.x,
-                                                              m_position.y,
-                                                              m_position.z,
-                                                              GeographicPositions::SPHERE);
-    return geocentricCoordinates;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetGeocentricPosition(const Vector& position)
-{
-    Vector geographicCoordinates =
-        GeographicPositions::CartesianToGeographicCoordinates(position,
-                                                              GeographicPositions::SPHERE);
-    m_position = geographicCoordinates;
-    NotifyCourseChange();
-}
-
-double
-GeocentricConstantPositionMobilityModel::DoGetElevationAngle(
-    Ptr<const GeocentricConstantPositionMobilityModel> other)
-{
-    Vector me = this->DoGetGeocentricPosition();
-    Vector them = other->DoGetGeocentricPosition();
-
-    // a is assumed to be the terminal with the lowest altitude
-    Vector& a = (me.z < them.z ? me : them);
-    Vector& b = (me.z < them.z ? them : me);
-
-    Vector bMinusA = b - a;
-    double numerator = std::abs(a * bMinusA);
-    double denominator = a.GetLength() * bMinusA.GetLength();
-    double x = numerator / denominator;
-
-    // Enforce the appropriate domain range ([-1, 1]) for the argument of std::asin.
-    x = std::min(x, 1.0);
-    x = std::max(x, -1.0);
-
-    // asin returns radians, we convert to degrees
-    double elevAngle = std::abs((180.0 * M_1_PI) * asin(x));
-
-    return elevAngle;
-}
-
-void
-GeocentricConstantPositionMobilityModel::DoSetCoordinateTranslationReferencePoint(
-    const Vector& refPoint)
-{
-    m_geographicReferencePoint = refPoint;
-}
-
-Vector
-GeocentricConstantPositionMobilityModel::DoGetCoordinateTranslationReferencePoint() const
-{
-    return m_geographicReferencePoint;
+GeocentricConstantPositionMobilityModel::DoSetPosition(const Vector& position, PositionType type)
+{
+    Vector geographicCoordinates;
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        geographicCoordinates =
+            GeographicPositions::TopocentricToGeographicCoordinates(position,
+                                                                    GetGeographicReferencePoint(),
+                                                                    GetEarthSpheroidType());
+        m_position = geographicCoordinates;
+        break;
+    case PositionType::GEOCENTRIC:
+        geographicCoordinates =
+            GeographicPositions::CartesianToGeographicCoordinates(position, GetEarthSpheroidType());
+        m_position = geographicCoordinates;
+        break;
+    case PositionType::GEOGRAPHIC:
+        m_position = position;
+        break;
+    default:
+        NS_ABORT_MSG("Unknown PositionType requested");
+        break;
+    }
 }
 
 Vector
diff --git a/src/mobility/model/geocentric-constant-position-mobility-model.h b/src/mobility/model/geocentric-constant-position-mobility-model.h
index b543c43ff..de9910763 100644
--- a/src/mobility/model/geocentric-constant-position-mobility-model.h
+++ b/src/mobility/model/geocentric-constant-position-mobility-model.h
@@ -4,11 +4,12 @@
  * SPDX-License-Identifier: GPL-2.0-only
  *
  * Author: Mattia Sandri <mattia.sandri@unipd.it>
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
  */
 #ifndef GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 #define GEOCENTRIC_CONSTANT_POSITION_MOBILITY_MODEL_H
 
-#include "geographic-positions.h"
+#include "geocentric-mobility-model.h"
 #include "mobility-model.h"
 
 /**
@@ -23,7 +24,7 @@ namespace ns3
 /**
  * @brief Mobility model using geocentric euclidean coordinates, as defined in 38.811 chapter 6.3
  */
-class GeocentricConstantPositionMobilityModel : public MobilityModel
+class GeocentricConstantPositionMobilityModel : public GeocentricMobilityModel
 {
   public:
     /**
@@ -37,113 +38,19 @@ class GeocentricConstantPositionMobilityModel : public MobilityModel
     GeocentricConstantPositionMobilityModel() = default;
     ~GeocentricConstantPositionMobilityModel() override = default;
 
-    /**
-     * @brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
-     * After calculating the plane perpendicular to a cartesian position vector,
-     * the elevation angle is calculated using
-     * https://www.w3schools.blog/angle-between-a-line-and-a-plane.
-     * The altitude of the position passed as a parameter must be higher than that of the reference
-     * point.
-     * @param other pointer to the HAPS/satellite mobility model
-     * @return the elevation angle
-     * in degrees
-     */
-    virtual double GetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-
-    /**
-     * @brief Get the position using geographic (geodetic) coordinates
-     * @return Vector containing (latitude (degree), longitude (degree), altitude (meter))
-     */
-    virtual Vector GetGeographicPosition() const;
-
-    /**
-     * @brief Set the position using geographic coordinates
-     *
-     * Sets the position, using geographic coordinates and asserting
-     * that the provided parameter falls within the appropriate range.
-     *
-     * @param latLonAlt pointer to a Vector containing (latitude (degree), longitude (degree),
-     * altitude (meter)). The values are expected to be in the ranges [-90, 90], [-180, 180], [0,
-     * +inf[, respectively. These assumptions are enforced with an assert for the latitude and the
-     * altitude, while the longitude is normalized to the expected range.
-     */
-    virtual void SetGeographicPosition(const Vector& latLonAlt);
-
-    /**
-     * @brief Get the position using Geocentric Cartesian coordinates
-     * @return Vector containing (x, y, z) (meter) coordinates
-     */
-    virtual Vector GetGeocentricPosition() const;
-
-    /**
-     * @brief Set the position using Geocentric Cartesian coordinates
-     * @param position pointer to a Vector containing (x, y, z) (meter) coordinates
-     */
-    virtual void SetGeocentricPosition(const Vector& position);
-
-    /**
-     * @brief Set the reference point for coordinate conversion
-     * @param refPoint vector containing the geographic reference point (meter)
-     */
-    virtual void SetCoordinateTranslationReferencePoint(const Vector& refPoint);
-
-    /**
-     * @brief Get the reference point for coordinate conversion
-     * @return Vector containing geographic reference point (meter)
-     */
-    virtual Vector GetCoordinateTranslationReferencePoint() const;
-
-    /**
-     * @return the current position
-     */
-    virtual Vector GetPosition() const;
-
-    /**
-     * @param position the position to set.
-     */
-    virtual void SetPosition(const Vector& position);
-
-    /**
-     * @param other a reference to another mobility model
-     * @return the distance between the two objects. Unit is meters.
-     */
-    double GetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
-
   private:
     /** @copydoc GetPosition() */
-    Vector DoGetPosition() const override;
+    Vector DoGetPosition(PositionType type) const override;
     /** @copydoc SetPosition() */
-    void DoSetPosition(const Vector& position) override;
+    void DoSetPosition(const Vector& position, PositionType type) override;
     /** @copydoc GetVelocity() */
     Vector DoGetVelocity() const override;
-    /** @copydoc GetDistanceFrom() */
-    double DoGetDistanceFrom(Ptr<const GeocentricConstantPositionMobilityModel> other) const;
-    /** @copydoc GetGeographicPosition() */
-    virtual Vector DoGetGeographicPosition() const;
-    /** @copydoc SetGeographicPosition() */
-    virtual void DoSetGeographicPosition(const Vector& latLonAlt);
-    /** @copydoc GetGeocentricPosition() */
-    virtual Vector DoGetGeocentricPosition() const;
-    /** @copydoc SetGeocentricPosition() */
-    virtual void DoSetGeocentricPosition(const Vector& position);
-    /** @copydoc GetElevationAngle() */
-    virtual double DoGetElevationAngle(Ptr<const GeocentricConstantPositionMobilityModel> other);
-    /** @copydoc SetCoordinateTranslationReferencePoint() */
-    virtual void DoSetCoordinateTranslationReferencePoint(const Vector& refPoint);
-    /** @copydoc GetCoordinateTranslationReferencePoint() */
-    virtual Vector DoGetCoordinateTranslationReferencePoint() const;
 
     /**
      * the constant Geographic position,, in order: latitude (degree), longitude (degree), altitude
      * (meter).
      */
     Vector m_position{0, 0, 0};
-
-    /**
-     * This is the point (meter) taken as a reference for converting
-     * from geographic to topographic (also referred to as planar Cartesian)
-     */
-    Vector m_geographicReferencePoint{0, 0, 0};
 };
 
 } // namespace ns3
diff --git a/src/mobility/model/geocentric-mobility-model.cc b/src/mobility/model/geocentric-mobility-model.cc
new file mode 100644
index 000000000..22b66525e
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.cc
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+
+#include "geocentric-mobility-model.h"
+
+#include <ns3/enum.h>
+
+#include <math.h>
+
+namespace ns3
+{
+
+std::ostream&
+operator<<(std::ostream& os, PositionType type)
+{
+    switch (type)
+    {
+    case PositionType::TOPOCENTRIC:
+        os << "TOPOCENTRIC";
+        break;
+    case PositionType::GEOCENTRIC:
+        os << "GEOCENTRIC";
+        break;
+    case PositionType::GEOGRAPHIC:
+        os << "GEOGRAPHIC";
+        break;
+    default:
+        os << "UNKNOWN";
+        break;
+    }
+    return os;
+}
+
+NS_OBJECT_ENSURE_REGISTERED(GeocentricMobilityModel);
+
+TypeId
+GeocentricMobilityModel::GetTypeId()
+{
+    static TypeId tid =
+        TypeId("ns3::GeocentricMobilityModel")
+            .SetParent<MobilityModel>()
+            .SetGroupName("Mobility")
+            .AddAttribute("EarthSpheroidType",
+                          "Spheroid model to use for Earth",
+                          EnumValue(GeographicPositions::WGS84),
+                          MakeEnumAccessor<GeographicPositions::EarthSpheroidType>(
+                              &GeocentricMobilityModel::m_earthSpheroidType),
+                          MakeEnumChecker(GeographicPositions::SPHERE,
+                                          "SPHERE",
+                                          GeographicPositions::GRS80,
+                                          "GRS80",
+                                          GeographicPositions::WGS84,
+                                          "WGS84"))
+            .AddAttribute(
+                "GeographicReferencePoint",
+                "The point taken as reference when converting from geographic to topographic.",
+                Vector3DValue({0, 0, 0}),
+                MakeVector3DAccessor(&GeocentricMobilityModel::m_geographicReferencePoint),
+                MakeVector3DChecker());
+    return tid;
+}
+
+Vector
+GeocentricMobilityModel::GetPosition(PositionType type) const
+{
+    return DoGetPosition(type);
+}
+
+void
+GeocentricMobilityModel::SetPosition(Vector position, PositionType type)
+{
+    DoSetPosition(position, type);
+}
+
+double
+GeocentricMobilityModel::GetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    return DoGetElevationAngle(other);
+}
+
+Vector
+GeocentricMobilityModel::GetGeographicReferencePoint() const
+{
+    return DoGetGeographicReferencePoint();
+}
+
+void
+GeocentricMobilityModel::SetGeographicReferencePoint(const Vector& position)
+{
+    DoSetGeographicReferencePoint(position);
+}
+
+GeographicPositions::EarthSpheroidType
+GeocentricMobilityModel::GetEarthSpheroidType() const
+{
+    return m_earthSpheroidType;
+}
+
+Vector
+GeocentricMobilityModel::DoGetPosition() const
+{
+    return DoGetPosition(PositionType::TOPOCENTRIC);
+}
+
+void
+GeocentricMobilityModel::DoSetPosition(const Vector& position)
+{
+    DoSetPosition(position, PositionType::GEOGRAPHIC);
+}
+
+double
+GeocentricMobilityModel::DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const
+{
+    Vector cartesianCoordA = DoGetPosition(PositionType::GEOCENTRIC);
+    Vector cartesianCoordB = other->DoGetPosition(PositionType::GEOCENTRIC);
+
+    double distance = (cartesianCoordA - cartesianCoordB).GetLength();
+
+    return distance;
+}
+
+double
+GeocentricMobilityModel::DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other)
+{
+    Vector me = this->DoGetPosition(PositionType::GEOCENTRIC);
+    Vector them = other->DoGetPosition(PositionType::GEOCENTRIC);
+
+    // a is assumed to be the terminal with the lowest altitude
+    Vector& a = (me.z < them.z ? me : them);
+    Vector& b = (me.z < them.z ? them : me);
+
+    Vector bMinusA = b - a;
+    double numerator = std::abs(a * bMinusA);
+    double denominator = a.GetLength() * bMinusA.GetLength();
+    double x = numerator / denominator;
+
+    // Enforce the appropriate domain range ([-1, 1]) for the argument of std::asin.
+    x = std::min(x, 1.0);
+    x = std::max(x, -1.0);
+
+    // asin returns radians, we convert to degrees
+    double elevAngle = abs((180.0 * M_1_PI) * asin(x));
+
+    return elevAngle;
+}
+
+void
+GeocentricMobilityModel::DoSetGeographicReferencePoint(const Vector& refPoint)
+{
+    m_geographicReferencePoint = refPoint;
+}
+
+Vector
+GeocentricMobilityModel::DoGetGeographicReferencePoint() const
+{
+    return m_geographicReferencePoint;
+}
+
+} // namespace ns3
\ No newline at end of file
diff --git a/src/mobility/model/geocentric-mobility-model.h b/src/mobility/model/geocentric-mobility-model.h
new file mode 100644
index 000000000..4e9bd7b64
--- /dev/null
+++ b/src/mobility/model/geocentric-mobility-model.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2023 University of Padua.
+ * Copyright (C) 2023 Polytechnic University of Bari.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Mattia Sandri <mattia.sandri@unipd.it>,
+ *         Giovanni Grieco <giovanni.grieco@poliba.it>
+ */
+#ifndef GEOCENTRIC_MOBILITY_MODEL_H
+#define GEOCENTRIC_MOBILITY_MODEL_H
+
+#include "geographic-positions.h"
+#include "mobility-model.h"
+
+namespace ns3
+{
+
+/**
+ * @brief The type of coordinates to use for position.
+ * @see ns3::GeographicPositions for more information on these different types of coordinates.
+ */
+enum class PositionType
+{
+    TOPOCENTRIC,
+    GEOCENTRIC,
+    GEOGRAPHIC
+};
+
+std::ostream& operator<<(std::ostream& os, PositionType type);
+
+/**
+ * @brief Abstract class to mark a mobility model that provides geocentric euclidean coordinates.
+ */
+class GeocentricMobilityModel : public MobilityModel
+{
+  public:
+    /**
+     * Register this type with the TypeId system.
+     * \return the object TypeId
+     */
+    static TypeId GetTypeId();
+    /**
+     * Create a position located at coordinates (0,0,0)
+     */
+    GeocentricMobilityModel() = default;
+    ~GeocentricMobilityModel() override = default;
+
+    /**
+     * @brief Get the current position by specifying the type of coordinates. Defaults to
+     * TOPOCENTRIC.
+     */
+    Vector GetPosition(PositionType type = PositionType::TOPOCENTRIC) const;
+
+    /**
+     * @brief Set the position by specifying the type of coordinates. Defaults to GEOGRAPHIC.
+     */
+    void SetPosition(Vector position, PositionType type = PositionType::GEOGRAPHIC);
+
+    /**
+     * @brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane.
+     * The altitude of the node passed as parameter needs to be higher than that of the reference
+     * point. @param other pointer to the HAPS/Satellite mobility model @return the elevation angle
+     * in degrees
+     */
+    double GetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+
+    /**
+     * @brief Get the reference point for coordinate translation
+     * @return Vector containing geographic reference point
+     */
+    Vector GetGeographicReferencePoint() const;
+
+    /**
+     * @brief Set the reference point for coordinate translation
+     * @param refPoint vector containing the geographic reference point
+     */
+    void SetGeographicReferencePoint(const Vector& refPoint);
+
+    /**
+     * @brief Get the Earth spheroid type used for this mobility model.
+     * @return Earth spheroid type
+     */
+    GeographicPositions::EarthSpheroidType GetEarthSpheroidType() const;
+
+  private:
+    /**
+     * @brief Get the TOPOCENTRIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    Vector DoGetPosition() const override;
+
+    /// @brief Get the position by specifying the type of coordinates.
+    virtual Vector DoGetPosition(PositionType type) const = 0;
+
+    /**
+     * @brief Set the GEOGRAPHIC coordinates. Override for ns-3 MobilityModel interface
+     * compatibility.
+     */
+    void DoSetPosition(const Vector& position) override;
+
+    /// @brief Set the position by specifying the type of coordinates.
+    virtual void DoSetPosition(const Vector& position, PositionType type) = 0;
+
+    /**
+     * @brief Get the distance between two nodes.
+     * @param other the mobility model for which the distance from will be calculated
+     * @return the distance in meters
+     */
+    virtual double DoGetDistanceFrom(Ptr<const GeocentricMobilityModel> other) const;
+
+    /**
+     * @brief Computes elevation angle between a ground terminal and a HAPS/Satellite.
+     * After calculating the plane perpendicular to one cartesian position vector,
+     * the elevation angle is calculated using
+     * https://www.w3schools.blog/angle-between-a-line-and-a-plane. The altitude of the node passed
+     * as parameter needs to be higher. @param other pointer to the HAPS/Satellite mobility model
+     * @return the elevation angle in degrees
+     */
+    virtual double DoGetElevationAngle(Ptr<const GeocentricMobilityModel> other);
+    /**
+     * @brief Set the reference point for coordinate translation
+     * @param refPoint vector containing the geographic reference point
+     */
+    virtual void DoSetGeographicReferencePoint(const Vector& refPoint);
+    /**
+     * @brief Get the reference point for coordinate translation
+     * @return Vector containing geographic reference point
+     */
+    virtual Vector DoGetGeographicReferencePoint() const;
+
+    GeographicPositions::EarthSpheroidType m_earthSpheroidType; //!< Spheroid model to use for Earth
+    Vector3D m_geographicReferencePoint; //!< Reference point for coordinate translation from
+                                         //!< geographic to topographic
+};
+
+} // namespace ns3
+
+#endif /* GEOCENTRIC_MOBILITY_MODEL_H */
\ No newline at end of file
diff --git a/src/mobility/model/geographic-positions.h b/src/mobility/model/geographic-positions.h
index 2d55581ab..94b56f8f3 100644
--- a/src/mobility/model/geographic-positions.h
+++ b/src/mobility/model/geographic-positions.h
@@ -72,6 +72,13 @@ class GeographicPositions
         WGS84
     };
 
+    /// Altitude limit of the Troposphere
+    static constexpr double TROPOSPHERE_MAX_ALT = 10e3;
+    /// Altitude limit of the Ionosphere
+    static constexpr double IONOSPHERE_MAX_ALT = 300e3;
+    /// Altitude limit of the Stratosphere
+    static constexpr double STRATOSPHERE_MAX_ALT = 50e3;
+
     /**
      * Converts earth geographic/geodetic coordinates (latitude and longitude in
      * degrees) with a given altitude above earth's surface (in meters) to Earth
diff --git a/src/propagation/model/channel-condition-model.cc b/src/propagation/model/channel-condition-model.cc
index 274e09d00..6d0afb476 100644
--- a/src/propagation/model/channel-condition-model.cc
+++ b/src/propagation/model/channel-condition-model.cc
@@ -9,7 +9,7 @@
 
 #include "ns3/boolean.h"
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -579,9 +579,9 @@ ThreeGppChannelConditionModel::GetQuantizedElevationAngle(Ptr<const MobilityMode
     Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(a);
     Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(b);
 
-    // check if aMob and bMob are of type GeocentricConstantPositionMobilityModel
-    auto aNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-    auto bNTNMob = DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+    // check if aMob and bMob are of type GeocentricMobilityModel
+    auto aNTNMob = DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+    auto bNTNMob = DynamicCast<GeocentricMobilityModel>(bMobNonConst);
     NS_ASSERT_MSG(aNTNMob && bNTNMob,
                   "Mobility Models need to be of type Geocentric for NTN scenarios");
 
diff --git a/src/propagation/model/three-gpp-propagation-loss-model.cc b/src/propagation/model/three-gpp-propagation-loss-model.cc
index fc6243906..c37c71eb0 100644
--- a/src/propagation/model/three-gpp-propagation-loss-model.cc
+++ b/src/propagation/model/three-gpp-propagation-loss-model.cc
@@ -11,7 +11,8 @@
 
 #include "ns3/boolean.h"
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
+#include "ns3/geographic-positions.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
 #include "ns3/node.h"
@@ -22,6 +23,9 @@
 
 namespace
 {
+
+constexpr double M_C = 3.0e8; //!< propagation velocity in free space
+
 /**
  * The enumerator used for code clarity when performing parameter assignment in the GetLoss Methods
  */
@@ -158,6 +162,23 @@ GetBsUtHeightsUmiStreetCanyon(double heightA, double heightB)
     return std::make_tuple(hBs, hUt);
 }
 
+/**
+ * @return The altitude of the lowest mobility model for NTN scenarios.
+ */
+double
+GetLowestNTNMobAltitude(ns3::Ptr<ns3::MobilityModel> a, ns3::Ptr<ns3::MobilityModel> b)
+{
+    auto aNTNMob = ns3::DynamicCast<ns3::GeocentricMobilityModel>(a);
+    auto bNTNMob = ns3::DynamicCast<ns3::GeocentricMobilityModel>(b);
+    NS_ASSERT_MSG(aNTNMob && bNTNMob,
+                  "Mobility Models need to be of type Geocentric for NTN scenarios");
+
+    auto posA = aNTNMob->GetPosition(ns3::PositionType::GEOGRAPHIC);
+    auto posB = bNTNMob->GetPosition(ns3::PositionType::GEOGRAPHIC);
+    auto lowestMobAltitude = (posA.z < posB.z) ? posA.z : posB.z;
+    return lowestMobAltitude;
+}
+
 /**
  * @brief Computes the free-space path loss using the formula described in 3GPP TR 38.811,
  * Table 6.6.2
@@ -205,15 +226,17 @@ ComputeAtmosphericAbsorptionLoss(double freq, double elevAngle)
  * @return the ionospheric plus tropospheric scintillation loss for NTN scenarios
  */
 double
-ComputeIonosphericPlusTroposphericScintillationLoss(double freq, double elevAngleQuantized)
+ComputeIonosphericPlusTroposphericScintillationLoss(double freq,
+                                                    double elevAngleQuantized,
+                                                    double lowestMobAltitude)
 {
     double loss = 0;
-    if (freq < 6e9)
+    if (freq < 6e9 && lowestMobAltitude < ns3::GeographicPositions::IONOSPHERE_MAX_ALT)
     {
         // Ionospheric
         loss = 6.22 / (pow(freq / 1e9, 1.5));
     }
-    else
+    if (freq >= 6e9 && lowestMobAltitude < ns3::GeographicPositions::TROPOSPHERE_MAX_ALT)
     {
         // Tropospheric
         loss = troposphericScintillationLoss.at(elevAngleQuantized);
@@ -252,8 +275,6 @@ ComputeClutterLoss(double freq,
     return loss;
 }
 
-constexpr double M_C = 3.0e8; //!< propagation velocity in free space
-
 } // namespace
 
 namespace ns3
@@ -1600,6 +1621,7 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1608,7 +1630,9 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1625,6 +1649,7 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1636,7 +1661,9 @@ ThreeGppNTNDenseUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1747,6 +1774,7 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1755,7 +1783,9 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1771,6 +1801,7 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1782,7 +1813,9 @@ ThreeGppNTNUrbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -1894,6 +1927,7 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1902,7 +1936,9 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossLos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
 
@@ -1920,6 +1956,7 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -1931,7 +1968,9 @@ ThreeGppNTNSuburbanPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a,
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -2042,6 +2081,7 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -2050,7 +2090,9 @@ ThreeGppNTNRuralPropagationLossModel::GetLossLos(Ptr<MobilityModel> a, Ptr<Mobil
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
@@ -2066,6 +2108,7 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     double distance3D = CalculateDistance(a->GetPosition(), b->GetPosition());
     auto [elevAngle, elevAngleQuantized] =
         ThreeGppChannelConditionModel::GetQuantizedElevationAngle(a, b);
+    auto lowestMobAltitude = GetLowestNTNMobAltitude(a, b);
 
     // compute the pathloss (see 3GPP TR 38.811, Table 6.6.2)
     double loss = ComputeNtnPathloss(m_frequency, distance3D);
@@ -2077,7 +2120,9 @@ ThreeGppNTNRuralPropagationLossModel::GetLossNlos(Ptr<MobilityModel> a, Ptr<Mobi
     loss += ComputeAtmosphericAbsorptionLoss(m_frequency, elevAngle);
 
     // Apply Ionospheric plus Tropospheric Scintillation Loss
-    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency, elevAngleQuantized);
+    loss += ComputeIonosphericPlusTroposphericScintillationLoss(m_frequency,
+                                                                elevAngleQuantized,
+                                                                lowestMobAltitude);
 
     NS_LOG_DEBUG("Loss " << loss);
     return loss;
diff --git a/src/spectrum/examples/three-gpp-ntn-channel-example.cc b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
index 29dfb6828..587f760af 100644
--- a/src/spectrum/examples/three-gpp-ntn-channel-example.cc
+++ b/src/spectrum/examples/three-gpp-ntn-channel-example.cc
@@ -25,6 +25,7 @@
 #include "ns3/constant-position-mobility-model.h"
 #include "ns3/core-module.h"
 #include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
 #include "ns3/isotropic-antenna-model.h"
 #include "ns3/mobility-model.h"
 #include "ns3/net-device.h"
@@ -423,14 +424,14 @@ main(int argc, char* argv[])
     Ptr<GeocentricConstantPositionMobilityModel> rxMob =
         CreateObject<GeocentricConstantPositionMobilityModel>();
 
-    txMob->SetGeographicPosition(Vector(45.40869, 11.89448, 35786000)); // GEO over Padova
-    rxMob->SetGeographicPosition(Vector(45.40869, 11.89448, 14.0));     // Padova Coordinates
+    txMob->SetPosition(Vector(45.40869, 11.89448, 35786000), PositionType::GEOGRAPHIC); // GEO over Padova
+    rxMob->SetPosition(Vector(45.40869, 11.89448, 14.0), PositionType::GEOGRAPHIC);     // Padova Coordinates
 
     // This is not strictly necessary, but is useful to have "sensible" values when using
     // GetPosition()
-    txMob->SetCoordinateTranslationReferencePoint(
+    txMob->SetGeographicReferencePoint(
         Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
-    rxMob->SetCoordinateTranslationReferencePoint(
+    rxMob->SetGeographicReferencePoint(
         Vector(45.40869, 11.89448, 0.0)); // Padova Coordinates without altitude
     // End changes with respect to three-gpp-channel-example,
 
diff --git a/src/spectrum/model/three-gpp-channel-model.cc b/src/spectrum/model/three-gpp-channel-model.cc
index 9d372d5b1..f0f792097 100644
--- a/src/spectrum/model/three-gpp-channel-model.cc
+++ b/src/spectrum/model/three-gpp-channel-model.cc
@@ -11,7 +11,8 @@
 #include "three-gpp-channel-model.h"
 
 #include "ns3/double.h"
-#include "ns3/geocentric-constant-position-mobility-model.h"
+#include "ns3/geocentric-mobility-model.h"
+#include "ns3/geographic-positions.h"
 #include "ns3/integer.h"
 #include "ns3/log.h"
 #include "ns3/mobility-model.h"
@@ -1888,22 +1889,23 @@ ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
         Ptr<MobilityModel> aMobNonConst = ConstCast<MobilityModel>(aMob);
         Ptr<MobilityModel> bMobNonConst = ConstCast<MobilityModel>(bMob);
 
-        if (DynamicCast<GeocentricConstantPositionMobilityModel>(
+        if (DynamicCast<GeocentricMobilityModel>(
                 ConstCast<MobilityModel>(aMob)) && // Transform to NS_ASSERT
-            DynamicCast<GeocentricConstantPositionMobilityModel>(
+            DynamicCast<GeocentricMobilityModel>(
                 ConstCast<MobilityModel>(bMob))) // check if aMob and bMob are of type
-                                                 // GeocentricConstantPositionMobilityModel
+                                                 // GeocentricMobilityModel
         {
-            Ptr<GeocentricConstantPositionMobilityModel> aNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(aMobNonConst);
-            Ptr<GeocentricConstantPositionMobilityModel> bNTNMob =
-                DynamicCast<GeocentricConstantPositionMobilityModel>(bMobNonConst);
+            Ptr<GeocentricMobilityModel> aNTNMob =
+                DynamicCast<GeocentricMobilityModel>(aMobNonConst);
+            Ptr<GeocentricMobilityModel> bNTNMob =
+                DynamicCast<GeocentricMobilityModel>(bMobNonConst);
 
-            if (aNTNMob->GetGeographicPosition().z <
-                bNTNMob->GetGeographicPosition().z) // b is the HAPS/Satellite
+            if (aNTNMob->GetPosition(PositionType::GEOGRAPHIC).z <
+                bNTNMob->GetPosition(PositionType::GEOGRAPHIC).z) // b is the HAPS/Satellite
             {
                 elevAngle = aNTNMob->GetElevationAngle(bNTNMob);
-                if (bNTNMob->GetGeographicPosition().z > 50000)
+                if (bNTNMob->GetPosition(PositionType::GEOGRAPHIC).z >
+                    GeographicPositions::STRATOSPHERE_MAX_ALT)
                 {
                     isSatellite = true;
                 }
@@ -1911,7 +1913,8 @@ ThreeGppChannelModel::GetThreeGppTable(const Ptr<const MobilityModel> aMob,
             else // a is the HAPS/Satellite
             {
                 elevAngle = bNTNMob->GetElevationAngle(aNTNMob);
-                if (aNTNMob->GetGeographicPosition().z > 50000)
+                if (aNTNMob->GetPosition(PositionType::GEOGRAPHIC).z >
+                    GeographicPositions::STRATOSPHERE_MAX_ALT)
                 {
                     isSatellite = true;
                 }
-- 
2.39.5 (Apple Git-154)

